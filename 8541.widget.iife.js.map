{"version":3,"file":"8541.widget.iife.js","mappings":"4RAGO,SAASA,EAAeC,EAAa,CAAC,GACzC,MAA2B,MAAvBA,EAAWC,SAAmBD,EAAWE,aAgMjD,SAAkBF,GAEd,IAAIG,EACAC,EACAC,EACAC,EACAC,EACJ,OAAO,EAAAC,EAAA,GAAiBC,IAAW,CAC/BC,GAAI,oBACJC,KAAM,kBACNC,KAAM,sBACNC,KAAMd,EAAec,KACrB,aAAMC,EAAQ,QAAEC,GAAY,CAAC,GACzB,IACI,MAAMC,QAAiBC,KAAKC,cACtBC,SAAkBH,EAASI,QAAQ,CACrCC,OAAQ,yBACRC,IAAKC,IAAM,EAAAC,EAAA,GAAWD,IACrBlB,IACDA,EAAkBY,KAAKQ,kBAAkBC,KAAKT,MAC9CD,EAASW,GAAG,kBAAmBtB,IAE9BC,IACDA,EAAeW,KAAKW,eAAeF,KAAKT,MACxCD,EAASW,GAAG,eAAgBrB,IAE3BC,IACDA,EAAaU,KAAKY,aAAaH,KAAKT,MACpCD,EAASW,GAAG,aAAcpB,IAG9B,IAAIuB,QAAuBb,KAAKc,aAChC,GAAIhB,GAAWe,IAAmBf,EAAS,CACvC,MAAMiB,QAAcf,KAAKgB,YAAY,CAAElB,YAAWmB,MAAOC,IACrD,GAAIA,EAAMC,OAAS,KAAyBA,KACxC,MAAMD,EACV,MAAO,CAAEzB,GAAIoB,KAEjBA,EAAiBE,GAAOtB,IAAMoB,CAClC,CACA,MAAO,CAAEX,WAAUJ,QAASe,EAChC,CACA,MAAOK,GACH,GAAI,sEAAsEE,KAAKF,EAAMG,SACjF,MAAM,IAAI,KAAyBH,GACvC,MAAMA,CACV,CACJ,EACA,gBAAM5B,GACF,MAAMS,QAAiBC,KAAKC,cACxBb,IACAW,EAASuB,eAAe,kBAAmBlC,GAC3CA,OAAkBmC,GAElBlC,IACAU,EAASuB,eAAe,eAAgBjC,GACxCA,OAAekC,GAEfjC,IACAS,EAASuB,eAAe,aAAchC,GACtCA,OAAaiC,GAEjBxB,EAAST,aACTS,EAASyB,OACb,EACA,iBAAMC,GACF,MAAM1B,QAAiBC,KAAKC,cAC5B,aAAcF,EAASI,QAAQ,CAC3BC,OAAQ,kBACRC,IAAKC,IAAM,EAAAC,EAAA,GAAWD,GAC9B,EACA,gBAAMQ,GACF,MAAMf,QAAiBC,KAAKC,cACtBH,QAAgBC,EAASI,QAAQ,CACnCC,OAAQ,gBAEZ,OAAOsB,OAAO5B,EAClB,EACA,iBAAMG,GACF,IAAKd,EAAgB,CAGjB,MAAMwC,OAA0B,WAC5B,MAAQC,QAASC,SAAc,qCAC/B,MAAmB,mBAARA,GAA6C,mBAAhBA,EAAID,QACjCC,EAAID,QACRC,CACV,EAL+B,GAMhC3C,EAAM,IAAIyC,EAAkB,IAAK5C,EAAY+C,mBAvF9B,QAyFf,MAAMC,EAAyB7C,EAAI8C,iBAAiBlB,aAC9CC,EAAQvB,EAAOyC,OAAOC,KAAMnB,GAAUhC,EAAWe,QACjDiB,EAAMtB,KAAOV,EAAWe,QACxBiB,EAAMtB,KAAOsC,IAA2BvC,EAAOyC,OAAO,GACtDnC,EAAUf,EAAWe,SAAWiB,GAAOtB,GACvC0C,EAAapD,EAAWoD,YAAcpB,GAAOqB,QAAQR,QAAQS,KAAK,GACxElD,EAAiBD,EAAIoD,iBAAiBH,EAAYrC,EACtD,CACA,OAAOX,CACX,EACA,kBAAMoD,GACF,IAEI,eADuBvC,KAAKyB,eACVe,MACtB,CACA,MACI,OAAO,CACX,CACJ,EACA,iBAAMxB,EAAY,0BAAEyB,EAAyB,QAAE3C,IAC3C,MAAMiB,EAAQvB,EAAOyC,OAAOC,KAAMnB,GAAUA,EAAMtB,KAAOK,GACzD,IAAKiB,EACD,MAAM,IAAI,KAAiB,IAAI,MACnC,MAAMhB,QAAiBC,KAAKC,cAC5B,IAKI,aAJMF,EAASI,QAAQ,CACnBC,OAAQ,6BACRsC,OAAQ,CAAC,CAAE5C,SAAS,QAAYiB,EAAMtB,QAEnCsB,CACX,CACA,MAAOG,GAEH,GAAmB,OAAfA,EAAMC,KACN,IACI,IAAIwB,EAOAP,EALAO,EADAF,GAA2BE,kBACPF,EAA0BE,kBAE1B5B,EAAM6B,gBAAgBhB,QAAQiB,IAC5C,CAAC9B,EAAM6B,gBAAgBhB,QAAQiB,KAC/B,GAGNT,EADAK,GAA2BL,SAASI,OAC1BC,EAA0BL,QAE1B,CAACrB,EAAMqB,QAAQR,SAASS,KAAK,IAAM,IACjD,MAAMS,EAAmB,CACrBH,oBACA7C,SAAS,QAAYA,GACrBiD,UAAWN,GAA2BM,WAAahC,EAAMrB,KACzDsD,SAAUP,GAA2BO,SACrCC,eAAgBR,GAA2BQ,gBACvClC,EAAMkC,eACVb,WAMJ,aAJMrC,EAASI,QAAQ,CACnBC,OAAQ,0BACRsC,OAAQ,CAACI,KAEN/B,CACX,CACA,MAAOG,GACH,MAAM,IAAI,KAAyBA,EACvC,CAEJ,MAAM,IAAI,KAAiBA,EAC/B,CACJ,EACA,iBAAAV,CAAkBN,GACU,IAApBA,EAASsC,OACTxC,KAAKY,eAELpB,EAAO0D,QAAQC,KAAK,SAAU,CAC1BjD,SAAUA,EAASG,IAAKC,IAAM,EAAAC,EAAA,GAAWD,KAErD,EACA,cAAAK,CAAeI,GACX,MAAMjB,EAAU4B,OAAOX,GACvBvB,EAAO0D,QAAQC,KAAK,SAAU,CAAErD,WACpC,EACA,kBAAMc,CAAawC,GACf5D,EAAO0D,QAAQC,KAAK,cACpB,MAAMpD,QAAiBC,KAAKC,cACxBb,IACAW,EAASuB,eAAe,kBAAmBlC,GAC3CA,OAAkBmC,GAElBlC,IACAU,EAASuB,eAAe,eAAgBjC,GACxCA,OAAekC,GAEfjC,IACAS,EAASuB,eAAe,aAAchC,GACtCA,OAAaiC,EAErB,IAER,CA3Xe8B,CAAStE,GAGxB,SAAkBA,GACd,IAAII,EACAC,EACAC,EACAC,EACJ,OAAO,EAAAC,EAAA,GAAiBC,IAAW,CAC/BC,GAAI,oBACJC,KAAM,kBACNC,KAAM,sBACNC,KAAMd,EAAec,KACrB,aAAMC,EAAQ,QAAEC,KAAYwD,GAAS,CAAC,GAClC,IACI,MAAMvD,QAAiBC,KAAKC,cACtBC,SAAkBH,EAASI,QAAQ,CACrCC,OAAQ,sBACRsC,OAAQ,sBAAuBY,GAAQA,EAAKC,kBACtC,CAAC,CAAEC,WAAY,YACf,MACNnD,IAAKC,IAAM,EAAAC,EAAA,GAAWD,IACrBlB,IACDA,EAAkBY,KAAKQ,kBAAkBC,KAAKT,MAC9CD,EAASW,GAAG,kBAAmBtB,IAE9BC,IACDA,EAAeW,KAAKW,eAAeF,KAAKT,MACxCD,EAASW,GAAG,eAAgBrB,IAE3BC,IACDA,EAAaU,KAAKY,aAAaH,KAAKT,MACpCD,EAASW,GAAG,aAAcpB,IAG9B,IAAIuB,QAAuBb,KAAKc,aAChC,GAAIhB,GAAWe,IAAmBf,EAAS,CACvC,MAAMiB,QAAcf,KAAKgB,YAAY,CAAElB,YAAWmB,MAAOC,IACrD,GAAIA,EAAMC,OAAS,KAAyBA,KACxC,MAAMD,EACV,MAAO,CAAEzB,GAAIoB,KAEjBA,EAAiBE,GAAOtB,IAAMoB,CAClC,CACA,MAAO,CAAEX,WAAUJ,QAASe,EAChC,CACA,MAAOK,GACH,GAAI,uFAAuFE,KAAKF,EAAMG,SAClG,MAAM,IAAI,KAAyBH,GACvC,MAAMA,CACV,CACJ,EACA,gBAAM5B,GACF,MAAMS,QAAiBC,KAAKC,cACxBb,IACAW,EAASuB,eAAe,kBAAmBlC,GAC3CA,OAAkBmC,GAElBlC,IACAU,EAASuB,eAAe,eAAgBjC,GACxCA,OAAekC,GAEfjC,IACAS,EAASuB,eAAe,aAAchC,GACtCA,OAAaiC,GAEjBxB,EAAST,aACTS,EAASyB,SACb,EACA,iBAAMC,GACF,MAAM1B,QAAiBC,KAAKC,cAC5B,aAAcF,EAASI,QAAQ,CAC3BC,OAAQ,kBACRC,IAAKC,IAAM,EAAAC,EAAA,GAAWD,GAC9B,EACA,gBAAMQ,GACF,MAAMf,QAAiBC,KAAKC,cACtBH,QAAiBC,EAASI,QAAQ,CACpCC,OAAQ,gBAEZ,OAAOsB,OAAO5B,EAClB,EACA,iBAAMG,GACF,IAAKd,EAAgB,CACjB,MAAMsE,EACmC,iBAA1B1E,EAAW0E,WACX,CAAEC,QAAS3E,EAAW0E,YAC1B,IACA1E,EAAW0E,WACdC,QAAS3E,EAAW0E,YAAYC,SAAW,QAG7C,wBAAEC,SAAkC,+BACpCzE,EAAMyE,EAAwB,IAC7B5E,EACH6E,YAAapE,EAAOyC,OAAO5B,IAAKC,GAAMA,EAAEb,IACxCgE,eAEJtE,EAAiBD,EAAIe,aACzB,CACA,OAAOd,CACX,EACA,kBAAMoD,GACF,IAEI,eADuBvC,KAAKyB,eACVe,MACtB,CACA,MACI,OAAO,CACX,CACJ,EACA,iBAAMxB,EAAY,0BAAEyB,EAAyB,QAAE3C,IAC3C,MAAMiB,EAAQvB,EAAOyC,OAAOC,KAAMnB,GAAUA,EAAMtB,KAAOK,GACzD,IAAKiB,EACD,MAAM,IAAI,KAAiB,IAAI,MACnC,MAAMhB,QAAiBC,KAAKC,cAC5B,IAKI,aAJMF,EAASI,QAAQ,CACnBC,OAAQ,6BACRsC,OAAQ,CAAC,CAAE5C,SAAS,QAAYiB,EAAMtB,QAEnCsB,CACX,CACA,MAAOG,GAEH,GAAmB,OAAfA,EAAMC,KACN,IACI,IAAIwB,EAOAP,EALAO,EADAF,GAA2BE,kBACPF,EAA0BE,kBAE1B5B,EAAM6B,gBAAgBhB,QAAQiB,IAC5C,CAAC9B,EAAM6B,gBAAgBhB,QAAQiB,KAC/B,GAGNT,EADAK,GAA2BL,SAASI,OAC1BC,EAA0BL,QAE1B,CAACrB,EAAMqB,QAAQR,SAASS,KAAK,IAAM,IACjD,MAAMS,EAAmB,CACrBH,oBACA7C,SAAS,QAAYA,GACrBiD,UAAWN,GAA2BM,WAAahC,EAAMrB,KACzDsD,SAAUP,GAA2BO,SACrCC,eAAgBR,GAA2BQ,gBACvClC,EAAMkC,eACVb,WAMJ,aAJMrC,EAASI,QAAQ,CACnBC,OAAQ,0BACRsC,OAAQ,CAACI,KAEN/B,CACX,CACA,MAAOG,GACH,MAAM,IAAI,KAAyBA,EACvC,CAEJ,MAAM,IAAI,KAAiBA,EAC/B,CACJ,EACA,iBAAAV,CAAkBN,GACU,IAApBA,EAASsC,OACTxC,KAAKY,eAELpB,EAAO0D,QAAQC,KAAK,SAAU,CAC1BjD,SAAUA,EAASG,IAAKC,IAAM,EAAAC,EAAA,GAAWD,KAErD,EACA,cAAAK,CAAeI,GACX,MAAMjB,EAAU4B,OAAOX,GACvBvB,EAAO0D,QAAQC,KAAK,SAAU,CAAErD,WACpC,EACA,kBAAMc,CAAawC,GACf5D,EAAO0D,QAAQC,KAAK,cACpB,MAAMpD,QAAiBC,KAAKC,cACxBb,IACAW,EAASuB,eAAe,kBAAmBlC,GAC3CA,OAAkBmC,GAElBlC,IACAU,EAASuB,eAAe,eAAgBjC,GACxCA,OAAekC,GAEfjC,IACAS,EAASuB,eAAe,aAAchC,GACtCA,OAAaiC,EAErB,IAER,CA7LWsC,CAAS9E,EACpB,CALAD,EAAec,KAAO,iB,0BCCf,SAASkE,EAAK/E,EAAa,CAAC,GAC/B,MAAM,eAAEgF,GAAiB,GAAUhF,EACnC,IAAIiF,EACA1E,EACJ,OAAO,EAAAC,EAAA,GAAiBC,IAAW,CAC/BC,GAAI,OACJC,KAAM,OACNE,KAAMkE,EAAKlE,KACX,aAAMC,GACF,MAAME,QAAiBC,KAAKC,cAC5B,IAAKF,EACD,MAAM,IAAI,IACd,MAAMG,QAAiBF,KAAKyB,cACtB3B,QAAgBE,KAAKc,aAQ3B,OAPKxB,IACDA,EAAaU,KAAKY,aAAaH,KAAKT,MACpCD,EAASW,GAAG,aAAcpB,IAG1ByE,SACMvE,EAAOyE,SAASC,WAAW,sBAC9B,CAAEhE,WAAUJ,UACvB,EACA,gBAAMR,GACF,MAAMS,QAAiBC,KAAKC,cAC5B,IAAKF,EACD,MAAM,IAAI,IACVT,IACAS,EAASuB,eAAe,aAAchC,GACtCA,OAAaiC,GAGbwC,SACMvE,EAAOyE,SAASE,QAAQ,qBAAqB,GAC3D,EACA,iBAAM1C,GACF,MAAM1B,QAAiBC,KAAKC,cAC5B,IAAKF,EACD,MAAM,IAAI,IACd,aAAcA,EAASI,QAAQ,CAAEC,OAAQ,kBAAmBC,IAAIE,EAAA,EACpE,EACA,iBAAMN,GAGF,GADmC,oBAAXmE,QAA0BA,QAAQC,SAAWD,OACrE,CAEA,IAAKJ,EAAW,CACZ,MAAQpC,QAASC,SAAc,gCACzB3C,EAAM,IAAI2C,EAAI9C,GAGd+E,QAAa,EAAAQ,EAAAC,GAAY,IAAMrF,EAAI4E,KAAKU,UAAW,CACrDC,QAAS1F,EAAW2F,yBAA2B,KAEnD,IAAKZ,EACD,MAAM,IAAIa,MAAM,mCAGpB,MAAMC,OAAwB,WAC1B,MAAMC,QAAiB,qCACvB,MAAwC,mBAA7BA,EAASD,iBAC4B,mBAArCC,EAASjD,QAAQgD,gBACjBC,EAASjD,QAAQgD,gBACrBC,EAASD,eACnB,EAN6B,GAO9BZ,EAAY,IAAIY,EAAgBd,EAAM5E,EAC1C,CACA,OAAO8E,CAtBG,CAuBd,EACA,gBAAMlD,GACF,MAAMf,QAAiBC,KAAKC,cAC5B,IAAKF,EACD,MAAM,IAAI,IACd,OAAO2B,OAAO3B,EAASD,QAC3B,EACA,kBAAMyC,GACF,IAII,QAHuBwB,UAEZvE,EAAOyE,SAASa,QAAQ,iCAGZ9E,KAAKyB,eACVe,MACtB,CACA,MACI,OAAO,CACX,CACJ,EACA,iBAAAhC,GAEA,EACA,cAAAG,GAEA,EACA,YAAAC,GACIpB,EAAO0D,QAAQC,KAAK,aACxB,IAER,CApGAW,EAAKlE,KAAO,M","sources":["webpack://HLWidget/../../node_modules/.pnpm/@wagmi+connectors@5.9.0_@types+react@19.1.8_@wagmi+core@2.18.0_@tanstack+query-core@5.83.0_@t_u3e7vt27o3hn7kvyurj2otlxxa/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js","webpack://HLWidget/../../node_modules/.pnpm/@wagmi+connectors@5.9.0_@types+react@19.1.8_@wagmi+core@2.18.0_@tanstack+query-core@5.83.0_@t_u3e7vt27o3hn7kvyurj2otlxxa/node_modules/@wagmi/connectors/dist/esm/safe.js"],"sourcesContent":["import { ChainNotConfiguredError, createConnector, } from '@wagmi/core';\nimport { SwitchChainError, UserRejectedRequestError, getAddress, numberToHex, } from 'viem';\ncoinbaseWallet.type = 'coinbaseWallet';\nexport function coinbaseWallet(parameters = {}) {\n    if (parameters.version === '3' || parameters.headlessMode)\n        return version3(parameters);\n    return version4(parameters);\n}\nfunction version4(parameters) {\n    let walletProvider;\n    let accountsChanged;\n    let chainChanged;\n    let disconnect;\n    return createConnector((config) => ({\n        id: 'coinbaseWalletSDK',\n        name: 'Coinbase Wallet',\n        rdns: 'com.coinbase.wallet',\n        type: coinbaseWallet.type,\n        async connect({ chainId, ...rest } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                    params: 'instantOnboarding' in rest && rest.instantOnboarding\n                        ? [{ onboarding: 'instant' }]\n                        : [],\n                })).map((x) => getAddress(x));\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return { accounts, chainId: currentChainId };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))\n                    throw new UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            provider.disconnect();\n            provider.close?.();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return (await provider.request({\n                method: 'eth_accounts',\n            })).map((x) => getAddress(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = (await provider.request({\n                method: 'eth_chainId',\n            }));\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                const preference = (() => {\n                    if (typeof parameters.preference === 'string')\n                        return { options: parameters.preference };\n                    return {\n                        ...parameters.preference,\n                        options: parameters.preference?.options ?? 'all',\n                    };\n                })();\n                const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk');\n                const sdk = createCoinbaseWalletSDK({\n                    ...parameters,\n                    appChainIds: config.chains.map((x) => x.id),\n                    preference,\n                });\n                walletProvider = sdk.getProvider();\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new SwitchChainError(new ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: numberToHex(chain.id) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                // Indicates chain is not added to provider\n                if (error.code === 4902) {\n                    try {\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else\n                            blockExplorerUrls = chain.blockExplorers?.default.url\n                                ? [chain.blockExplorers?.default.url]\n                                : [];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: numberToHex(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [addEthereumChain],\n                        });\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new UserRejectedRequestError(error);\n                    }\n                }\n                throw new SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => getAddress(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect(_error) {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n        },\n    }));\n}\nfunction version3(parameters) {\n    const reloadOnDisconnect = false;\n    let sdk;\n    let walletProvider;\n    let accountsChanged;\n    let chainChanged;\n    let disconnect;\n    return createConnector((config) => ({\n        id: 'coinbaseWalletSDK',\n        name: 'Coinbase Wallet',\n        rdns: 'com.coinbase.wallet',\n        type: coinbaseWallet.type,\n        async connect({ chainId } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                })).map((x) => getAddress(x));\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return { accounts, chainId: currentChainId };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))\n                    throw new UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            provider.disconnect();\n            provider.close();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return (await provider.request({\n                method: 'eth_accounts',\n            })).map((x) => getAddress(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = await provider.request({\n                method: 'eth_chainId',\n            });\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                // Unwrapping import for Vite compatibility.\n                // See: https://github.com/vitejs/vite/issues/9703\n                const CoinbaseWalletSDK = await (async () => {\n                    const { default: SDK } = await import('cbw-sdk');\n                    if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n                        return SDK.default;\n                    return SDK;\n                })();\n                sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });\n                // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n                const walletExtensionChainId = sdk.walletExtension?.getChainId();\n                const chain = config.chains.find((chain) => parameters.chainId\n                    ? chain.id === parameters.chainId\n                    : chain.id === walletExtensionChainId) || config.chains[0];\n                const chainId = parameters.chainId || chain?.id;\n                const jsonRpcUrl = parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0];\n                walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new SwitchChainError(new ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: numberToHex(chain.id) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                // Indicates chain is not added to provider\n                if (error.code === 4902) {\n                    try {\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else\n                            blockExplorerUrls = chain.blockExplorers?.default.url\n                                ? [chain.blockExplorers?.default.url]\n                                : [];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: numberToHex(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [addEthereumChain],\n                        });\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new UserRejectedRequestError(error);\n                    }\n                }\n                throw new SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => getAddress(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect(_error) {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n        },\n    }));\n}\n//# sourceMappingURL=coinbaseWallet.js.map","import { ProviderNotFoundError, createConnector, } from '@wagmi/core';\nimport { getAddress, withTimeout } from 'viem';\nsafe.type = 'safe';\nexport function safe(parameters = {}) {\n    const { shimDisconnect = false } = parameters;\n    let provider_;\n    let disconnect;\n    return createConnector((config) => ({\n        id: 'safe',\n        name: 'Safe',\n        type: safe.type,\n        async connect() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const accounts = await this.getAccounts();\n            const chainId = await this.getChainId();\n            if (!disconnect) {\n                disconnect = this.onDisconnect.bind(this);\n                provider.on('disconnect', disconnect);\n            }\n            // Remove disconnected shim if it exists\n            if (shimDisconnect)\n                await config.storage?.removeItem('safe.disconnected');\n            return { accounts, chainId };\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            // Add shim signalling connector is disconnected\n            if (shimDisconnect)\n                await config.storage?.setItem('safe.disconnected', true);\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            return (await provider.request({ method: 'eth_accounts' })).map(getAddress);\n        },\n        async getProvider() {\n            // Only allowed in iframe context\n            const isIframe = typeof window !== 'undefined' && window?.parent !== window;\n            if (!isIframe)\n                return;\n            if (!provider_) {\n                const { default: SDK } = await import('@safe-global/safe-apps-sdk');\n                const sdk = new SDK(parameters);\n                // `getInfo` hangs when not used in Safe App iFrame\n                // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n                const safe = await withTimeout(() => sdk.safe.getInfo(), {\n                    timeout: parameters.unstable_getInfoTimeout ?? 10,\n                });\n                if (!safe)\n                    throw new Error('Could not load Safe information');\n                // Unwrapping import for Vite compatibility.\n                // See: https://github.com/vitejs/vite/issues/9703\n                const SafeAppProvider = await (async () => {\n                    const Provider = await import('@safe-global/safe-apps-provider');\n                    if (typeof Provider.SafeAppProvider !== 'function' &&\n                        typeof Provider.default.SafeAppProvider === 'function')\n                        return Provider.default.SafeAppProvider;\n                    return Provider.SafeAppProvider;\n                })();\n                provider_ = new SafeAppProvider(safe, sdk);\n            }\n            return provider_;\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            return Number(provider.chainId);\n        },\n        async isAuthorized() {\n            try {\n                const isDisconnected = shimDisconnect &&\n                    // If shim exists in storage, connector is disconnected\n                    (await config.storage?.getItem('safe.disconnected'));\n                if (isDisconnected)\n                    return false;\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        onAccountsChanged() {\n            // Not relevant for Safe because changing account requires app reload.\n        },\n        onChainChanged() {\n            // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n        },\n        onDisconnect() {\n            config.emitter.emit('disconnect');\n        },\n    }));\n}\n//# sourceMappingURL=safe.js.map"],"names":["coinbaseWallet","parameters","version","headlessMode","sdk","walletProvider","accountsChanged","chainChanged","disconnect","createConnector","config","id","name","rdns","type","connect","chainId","provider","this","getProvider","accounts","request","method","map","x","getAddress","onAccountsChanged","bind","on","onChainChanged","onDisconnect","currentChainId","getChainId","chain","switchChain","catch","error","code","test","message","removeListener","undefined","close","getAccounts","Number","CoinbaseWalletSDK","default","SDK","reloadOnDisconnect","walletExtensionChainId","walletExtension","chains","find","jsonRpcUrl","rpcUrls","http","makeWeb3Provider","isAuthorized","length","addEthereumChainParameter","params","blockExplorerUrls","blockExplorers","url","addEthereumChain","chainName","iconUrls","nativeCurrency","emitter","emit","_error","version3","rest","instantOnboarding","onboarding","preference","options","createCoinbaseWalletSDK","appChainIds","version4","safe","shimDisconnect","provider_","storage","removeItem","setItem","window","parent","withTimeout","w","getInfo","timeout","unstable_getInfoTimeout","Error","SafeAppProvider","Provider","getItem"],"sourceRoot":""}